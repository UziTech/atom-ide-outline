{"version":3,"file":"main.js","sources":["../src/outlineView.js","../src/statuses.js","../src/main.js","../src/providerRegistry.js"],"sourcesContent":["export class OutlineView {\n  constructor() {\n    this.element = document.createElement(\"div\");\n    this.element.classList.add(\"outline-view\");\n  }\n\n  destroy() {\n    this.element.remove();\n  }\n\n  getElement() {\n    return this.element;\n  }\n\n  getTitle() {\n    return \"Outline\";\n  }\n\n  setOutline({ tree: outlineTree, editor }) {\n    const outlineViewElement = this.getElement();\n    outlineViewElement.innerHTML = \"\";\n\n    const outlineRoot = document.createElement(\"ul\");\n    addOutlineEntries({\n      parent: outlineRoot,\n      entries: outlineTree,\n      editor,\n    });\n    outlineViewElement.append(outlineRoot);\n  }\n\n  clearOutline() {\n    const outlineViewElement = this.getElement();\n    outlineViewElement.innerHTML = \"\";\n  }\n\n  presentStatus(status) {\n    this.clearOutline();\n\n    const statusElement = status && generateStatusElement(status);\n\n    if (statusElement) {\n      const outlineViewElement = this.getElement();\n      outlineViewElement.append(statusElement);\n    }\n  }\n}\n\nfunction generateStatusElement(status) {\n  const element = document.createElement(\"div\");\n  element.className = \"status\";\n\n  const { title = \"\", description = \"\" } = status;\n  element.innerHTML = `<h1>${title}</h1>\n  <span>${description}</span>`;\n\n  return element;\n}\n\nfunction addOutlineEntries({ parent, entries, editor, level = 0 }) {\n  entries.forEach((item) => {\n    const symbol = document.createElement(\"li\");\n\n    // Hold an entry in a dedicated element to prevent hover conflicts - hover over an <li> tag would be cought by a parent <li>\n    const labelElement = document.createElement(\"span\");\n    labelElement.style.paddingLeft = `${10 * level}px`;\n    labelElement.innerText = item.representativeName;\n\n    const iconElement = getIcon(item.icon);\n    labelElement.prepend(iconElement);\n\n    symbol.append(labelElement);\n\n    // Cursor reposition on click\n    symbol.addEventListener(\"click\", () => {\n      const editorPane = atom.workspace.paneForItem(editor);\n      editorPane.activate();\n\n      editor.cursors[0].setBufferPosition(item.startPosition, {\n        autoscroll: true,\n      });\n    });\n\n    const hasChildren = item.children && !!item.children[0];\n    if (hasChildren) {\n      const childrenList = document.createElement(\"ul\");\n      childrenList.addEventListener(\"click\", (event) =>\n        event.stopPropagation()\n      );\n\n      symbol.append(childrenList);\n      addOutlineEntries({\n        parent: childrenList,\n        entries: item.children,\n        editor,\n        level: level + 1,\n      });\n    }\n\n    parent.append(symbol);\n  });\n}\n\nfunction getIcon(iconType) {\n  // LSP specification: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_documentSymbol\n  // atom-languageclient mapping: https://github.com/atom/atom-languageclient/blob/485bb9d706b422456640c9070eee456ef2cf09c0/lib/adapters/outline-view-adapter.ts#L270\n\n  const iconElement = document.createElement(\"span\");\n  const hasIconType = typeof iconType === \"string\" && iconType.length > 0;\n\n  iconElement.className = hasIconType ? `icon ${iconType}` : \"icon\";\n\n  const type = hasIconType && iconType.replace(\"type-\", \"\");\n  const iconSymbol = type ? type.substring(0, 1) : \"?\";\n  iconElement.innerHTML = `<span>${iconSymbol}</span>`;\n\n  return iconElement;\n}\n","export const statuses = {\n  noEditor: {\n    title: \"Outline is unavailable.\",\n    description: \"Open a text editor.\",\n  },\n  noProvider: {\n    title: \"Provider is unavailable\",\n    description:\n      \"Looks like a provider for this type of file is not available. Check if a relevant IDE language package is installed and has outline support, or try adding one from Atom's package registry (e.g.: ide-typescript, ide-rust, ide-css, ide-json).\",\n  },\n};\n","import { CompositeDisposable, TextEditor } from \"atom\";\nimport { OutlineView } from \"./outlineView\";\nimport { ProviderRegistry } from \"./providerRegistry\";\n\nexport { statuses } from \"./statuses\"; // for spec\nimport { statuses } from \"./statuses\";\n\nlet subscriptions: CompositeDisposable;\nlet activeEditorContentUpdateSubscription = null;\nlet view: OutlineView;\nexport let outlineProviderRegistry = new ProviderRegistry();\nlet busySignalProvider;\n\nexport function activate() {\n  subscriptions = new CompositeDisposable();\n  view = new OutlineView(); // create outline pane\n  addCommands();\n  addObservers();\n}\n\nexport function deactivate() {\n  subscriptions.dispose();\n  view.destroy();\n}\n\nexport function consumeSignal(registry) {\n  const provider = registry.create();\n\n  busySignalProvider = provider;\n  subscriptions.add(provider);\n}\n\nexport async function consumeOutlineProvider(provider) {\n  const providerRegistryEntry = outlineProviderRegistry.addProvider(provider);\n  subscriptions.add(providerRegistryEntry);\n\n  // Generate (try) an outline after obtaining a provider\n  await getOutline();\n}\n\nfunction addCommands() {\n  const outlineToggle = atom.commands.add(\"atom-workspace\", {\n    \"outline:toggle\": () => toggleOutlineView(),\n  });\n  subscriptions.add(outlineToggle);\n}\n\nfunction addObservers() {\n  const activeTextEditorObserver = atom.workspace.observeActiveTextEditor(\n    async (editor: TextEditor) => {\n      activeEditorContentUpdateSubscription?.dispose?.(); // dispose old content\n      await getOutline(editor); // initial outline\n      // changing of outline by changing the cursor\n      activeEditorContentUpdateSubscription = editor?.onDidChangeCursorPosition(\n        () => getOutline(editor)\n      );\n    }\n  );\n  subscriptions.add(activeTextEditorObserver);\n}\n\nexport function toggleOutlineView() {\n  const outlinePane = atom.workspace.paneForItem(view);\n  if (outlinePane) {\n    return outlinePane.destroyItem(view);\n  }\n\n  const rightDock = atom.workspace.getRightDock();\n  const [pane] = rightDock.getPanes();\n\n  pane.addItem(view);\n  pane.activateItem(view);\n\n  rightDock.show();\n}\n\nexport async function getOutline(activeEditor) {\n  // editor\n  const editor = activeEditor || atom.workspace.getActiveTextEditor();\n  if (!editor) {\n    return setStatus(\"noEditor\");\n  }\n\n  // provider\n  const provider = outlineProviderRegistry.getProvider(editor);\n\n  if (!provider) {\n    return setStatus(\"noProvider\");\n  }\n\n  const target = editor.getFileName();\n  busySignalProvider?.add(`Outline: ${target}`);\n\n  const outline = await provider.getOutline(editor);\n\n  view.setOutline({\n    tree: (outline && outline.outlineTrees) || [],\n    editor,\n  });\n\n  busySignalProvider?.clear();\n}\n\nexport function setStatus(id) {\n  const status = statuses[id];\n  view.presentStatus(status);\n}\n","import { Disposable } from \"atom\";\n\nexport class ProviderRegistry {\n  constructor() {\n    this.providers = [];\n  }\n\n  addProvider(provider) {\n    this.providers.push(provider);\n\n    return new Disposable(() => this.removeProvider(provider));\n  }\n\n  removeProvider(provider) {\n    const indexInRegistry = this.providers.indexOf(provider);\n\n    if (indexInRegistry !== -1) {\n      this.providers.splice(indexInRegistry, 1);\n    }\n  }\n\n  getProvider(editor) {\n    const grammarScope = editor.getGrammar().scopeName;\n\n    return this.providers.find((provider) =>\n      provider.grammarScopes.includes(grammarScope)\n    );\n  }\n}\n"],"names":["OutlineView","constructor","element","document","createElement","classList","add","destroy","remove","getElement","this","getTitle","setOutline","tree","outlineTree","editor","outlineViewElement","innerHTML","outlineRoot","addOutlineEntries","parent","entries","level","forEach","item","symbol","labelElement","style","paddingLeft","innerText","representativeName","iconElement","iconType","hasIconType","length","className","type","replace","iconSymbol","substring","getIcon","icon","prepend","append","addEventListener","atom","workspace","paneForItem","activate","cursors","setBufferPosition","startPosition","autoscroll","children","childrenList","event","stopPropagation","clearOutline","presentStatus","status","statusElement","title","description","generateStatusElement","statuses","noEditor","noProvider","subscriptions","view","busySignalProvider","activeEditorContentUpdateSubscription","outlineProviderRegistry","providers","addProvider","provider","push","Disposable","removeProvider","indexInRegistry","indexOf","splice","getProvider","grammarScope","getGrammar","scopeName","find","grammarScopes","includes","toggleOutlineView","outlinePane","destroyItem","rightDock","getRightDock","pane","getPanes","addItem","activateItem","show","async","getOutline","activeEditor","getActiveTextEditor","setStatus","target","getFileName","outline","outlineTrees","clear","id","CompositeDisposable","outlineToggle","commands","addCommands","activeTextEditorObserver","observeActiveTextEditor","dispose","onDidChangeCursorPosition","addObservers","providerRegistryEntry","registry","create"],"mappings":"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"}